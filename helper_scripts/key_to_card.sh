#!/bin/bash

#################################################################
##                   READ BEFORE USE                           ##
#################################################################
##                                                             ##
##   This script takes the subkeys generated by the            ##
##   subkey_gen.sh script and copies them to the               ##
##   connected Yubikey. Please note that the script            ##
##   expects a blank Yubikey!                                  ##
##                                                             ##
##   Usage:                                                    ##
##   expect ./key_to_card.sh -i <key_id>                       ##
##                                                             ##
##   Advanced Usage:                                           ##
##   expect ./key_to_card.sh -i <key_id> \                     ##
##                           -g <GNUPGHOME> \                  ##
##                           -k <key_pass> \                   ##
##                           -a <admin pin>                    ##
##                                                             ##
#################################################################

VERSION="2.1.2"

# Functions to print in ❀pretty colors❀
function red(){
    echo -e "\x1B[31m $1 \x1B[0m"
    if [ -n "${2}" ]; then
    echo -e "\x1B[31m $($2) \x1B[0m"
    fi
}
function yellow(){
    echo -e "\x1B[33m $1 \x1B[0m"
    if [ -n "${2}" ]; then
    echo -e "\x1B[33m $($2) \x1B[0m"
    fi
}
function green(){
    echo -e "\x1B[32m $1 \x1B[0m"
    if [ -n "${2}" ]; then
    echo -e "\x1B[32m $($2) \x1B[0m"
    fi
}

# Usage for the script. Printed when something goes wrong or a parameter is missing
function usage()
{
   cat << HEREDOC
    This script takes the subkeys generated by the subkey_gen.sh script and copies them to the connected Yubikey. Please note that the script expects a blank Yubikey

   Usage: ${progname} {-k|--key-id <key_id>} [-g|--gnupg-home <dir>] [-p|--passphrase <passphrase>] [-a|--admin-pin <admin_pin>]

   required arguments:
     -k, --key-id        ID of PGP key to be uploaded to yubikey.

   optional arguments:
     -h, --help           show this help message and exit
     -g, --gnupg-home     provide gnupg home directory. Defauts to ~/.gnupg
     -p, --passphrase     provide passphrase for OpenPGP key. Defaults to blank password
     -a, --admin-pin      provide admin pin for yubikey. Defaults to 12345678
     -v, --version        print version number and exit
HEREDOC
}
progname=$(basename "${0}")

# Parse arguments... So complicated in bash....
POSITIONAL_ARGS=()
while [[ $# -gt 0 ]]; do
  case $1 in
    -v|--version)
      echo ${VERSION}
      exit 0
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    -k|--key-id*)
      KEY_ID="$2"
      shift
      shift
      ;;
    -g|--gnupg-home*)
      GNUPGHOME="$2"
      shift
      shift
      ;;
    -p|--passphrase*)
      KEY_PASS="$2" # Set the password variable
      shift
      shift
      ;;
    -a|--admin-pin*)
      ADMIN_PIN="$2"
      shift
      shift
      ;;
    -*)
      red "Unknown option '${1}'"
      usage
      exit 1
      ;;
    *)
      POSITIONAL_ARGS+=("${1}") # save positional arg
      shift # past argument
      ;;
  esac
done
set -- "${POSITIONAL_ARGS[@]}" # restore positional parameters

# Check the parameters, see if the required ones exist and set sensible defaults if unprovided
if [ -x ${KEY_ID+x} ]; then
  red "Missing Key ID! Exiting...."
  exit 1
fi

if [ -x ${KEY_PASS+x} ]; then
    KEY_PASS=""
    yellow "No password provided to script. Assuming key has no password."
fi

if [ -x ${ADMIN_PIN+x} ]; then
  ADMIN_PIN="12345678"
  yellow "No Admin pin provided. Assuming pin is ${ADMIN_PIN}"
fi

# Set the right user
if [ -z ${SUDO_USER+x} ]; then
  USER_NAME=${USER}
else
  USER_NAME=${SUDO_USER}
fi

EXPECT_PARAMETERS="-c"

# Set GNUPGHOME if none is provided.
if [ -x ${GNUPGHOME+x} ]; then

  # Get the machine type
  unameOut="$(uname -s)"
  case "${unameOut}" in
      Linux*)     machine=Linux;;
      Darwin*)    machine=Mac;;
      *)          machine="UNKNOWN:${unameOut}"
  esac

  # Choose the right gnupg default for the machine type
  if [ "${machine}" == "Linux" ]; then
    green "Linux detected"
    GNUPGHOME="/home/${USER_NAME}/.gnupg"
    yellow "GNUPGHOME set to ${GNUPGHOME}"

  elif [ "${machine}" == "Mac" ]; then
    green "MacOS detected"
    GNUPGHOME="/Users/${USER_NAME}/.gnupg"
    yellow "GNUPGHOME set to ${GNUPGHOME}"
    yellow "Debug mode enabled for expect. This is needed because of MacOS's bad terminal design."
    EXPECT_PARAMETERS="-d -c"
  fi
fi

# Check that the gnupg folder actually exists
if [ ! -d "${GNUPGHOME}" ]; then
  red "Folder '${GNUPGHOME}' does not exist!"
  exit 1
fi

# Check that the smartcard is connected
while true; do
  if ! gpg  --homedir "${GNUPGHOME}" --card-status; then
    yellow "Please (re)insert your OpenPGP smart card and press Enter"
    read -r _
    continue
  else
    break
  fi
done



# And finally move the cards to the key.
# If no passphrase is passed, we can assume the key has no password and
# we won't get prompted for the key's password when transfering the key to the card.
if [ "${KEY_PASS}" == "" ]; then
  expect ${EXPECT_PARAMETERS} "
  set timeout 5
  set ret 1
  set send_slow {10 .001}
  spawn gpg --homedir ${GNUPGHOME} --pinentry-mode loopback --edit-key ${KEY_ID}

  # Move Signature subkey
  expect \"gpg>\"
  send -s \"key 1\r\"
  expect \"gpg>\"
  send -s \"keytocard\r\"
  expect -- \"Your selection? \"
  send -s \"1\r\"
  expect \"Enter passphrase: \"
  send -s \"${ADMIN_PIN}\r\"
  expect \"Enter passphrase: \"
  send -s \"${ADMIN_PIN}\r\"
  expect {
    -re \"failed\"        { exit 1 }
    -re \"gpg>\"          { send -s \"key 1\r\" }
    timeout               { exit 1 }
  }

  # Move encryption subkey
  expect \"gpg>\"
  send -s \"key 2\r\"
  expect \"gpg>\"
  send -s \"keytocard\r\"
  expect -- \"Your selection? \"
  send -s \"2\r\"
  expect \"Enter passphrase: \"
  send -s \"${ADMIN_PIN}\r\"
  expect {
    -re \"failed\"        { exit 1 }
    -re \"gpg>\"          { send -s \"key 2\r\" }
    timeout               { exit 1 }
  }

  # Move authentication subkey
  expect \"gpg>\"
  send -s \"key 3\r\"
  expect \"gpg>\"
  send -s \"keytocard\r\"
  expect -- \"Your selection? \"
  send -s \"3\r\"
  expect \"Enter passphrase: \"
  send -s \"${ADMIN_PIN}\r\"
  expect {
    -re \"failed\"        { exit 1 }
    -re \"gpg>\"          { send -s \"save\r\" }
    timeout               { exit 1 }
  }

  expect eof
  set ret 0" || exit 1

else
  expect ${EXPECT_PARAMETERS} "
  set send_slow {10 .001}
  set timeout 5
  set ret 1
  spawn gpg --homedir ${GNUPGHOME} --pinentry-mode loopback --edit-key ${KEY_ID} --passphrase ${KEY_PASS}

  # Move Signature subkey
  expect \"gpg>\"
  send -s \"key 1\r\"
  expect \"gpg>\"
  send -s \"keytocard\r\"
  expect -- \"Your selection? \"
  send -s \"1\r\"
  expect \"Enter passphrase: \"
  send -s \"$KEY_PASS\r\"
  expect \"Enter passphrase: \"
  send -s \"$ADMIN_PIN\r\"
  expect \"Enter passphrase: \"
  send -s \"$ADMIN_PIN\r\"
  expect {
    -re \"failed\"        { exit 1 }
    -re \"gpg>\"          { send -s \"key 1\r\" }
    timeout               { exit 1 }
  }

  # Move encryption subkey
  expect \"gpg>\"
  send -s \"key 2\r\"
  expect \"gpg>\"
  send -s \"keytocard\r\"
  expect -- \"Your selection? \"
  send -s \"2\r\"
  expect \"Enter passphrase: \"
  send -s \"${KEY_PASS}\r\"
  expect \"Enter passphrase: \"
  send -s \"${ADMIN_PIN}\r\"
  expect {
    -re \"failed\"        { exit 1 }
    -re \"gpg>\"          { send -s \"key 2\r\" }
    timeout               { exit 1 }
  }


  # Move authentication subkey
  expect \"gpg>\"
  send -s \"key 3\r\"
  expect \"gpg>\"
  send -s \"keytocard\r\"
  expect -- \"Your selection? \"
  send -s \"3\r\"
  expect \"Enter passphrase: \"
  send -s \"${KEY_PASS}\r\"
  expect \"Enter passphrase: \"
  send -s \"${ADMIN_PIN}\r\"
  expect {
    -re \"failed\"        { exit 1 }
    -re \"gpg>\"          { send -s \"save\r\" }
    timeout               { exit 1 }
  }


  expect eof
  set ret 0" || exit 1
fi
